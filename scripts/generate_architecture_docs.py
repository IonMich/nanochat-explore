#!/usr/bin/env python3
"""
Generate architecture docs and UI payload from one source file.

Single source of truth:
    dev/architecture_blocks.source.json

Outputs:
    - dev/DEFAULT_MODEL_BUILDING_BLOCKS.md
    - dev/architecture_blocks.ui.json
"""

from __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path


ROOT = Path(__file__).resolve().parent.parent
SOURCE_PATH = ROOT / "dev" / "architecture_blocks.source.json"


def format_ref(path: str, start: int, end: int) -> str:
    if start == end:
        return f"`{path}:{start}`"
    return f"`{path}:{start}-{end}`"


def read_snippet(path: str, start: int, end: int) -> dict:
    file_path = ROOT / path
    if not file_path.exists():
        raise FileNotFoundError(f"Snippet source file not found: {path}")
    lines = file_path.read_text(encoding="utf-8").splitlines()
    if start < 1 or end < start:
        raise ValueError(f"Invalid snippet range {path}:{start}-{end}")
    if end > len(lines):
        raise ValueError(f"Snippet end out of range for {path}:{start}-{end} (file has {len(lines)} lines)")

    snippet_lines = lines[start - 1 : end]
    code = "\n".join(f"{lineno:4d} | {line}" for lineno, line in zip(range(start, end + 1), snippet_lines))
    return {
        "path": path,
        "start": start,
        "end": end,
        "line_count": len(snippet_lines),
        "code": code,
    }


def generate_markdown(data: dict, generated_at_utc: str) -> str:
    lines: list[str] = []
    lines.append("# Default Nanochat Model Building Blocks")
    lines.append("")
    lines.append(f"_Generated from `dev/architecture_blocks.source.json` on {generated_at_utc}. Do not edit this file directly._")
    lines.append("")
    lines.append("Default checkpoint path:")
    for step in data["default_path"]:
        lines.append(f"- `{step}`")
    lines.append("")

    for idx, block in enumerate(data["blocks"], start=1):
        lines.append(f"## {idx}) {block['title']}")
        lines.append("")
        for paragraph in block.get("commentary", []):
            lines.append(f"- {paragraph}")
        lines.append("")
        refs = block.get("references", [])
        if refs:
            lines.append("Code locations:")
            for ref in refs:
                lines.append(f"- {format_ref(ref['path'], ref['start'], ref['end'])}")
            lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def build_ui_data(data: dict, generated_at_utc: str) -> dict:
    ui_data = {
        "title": data["title"],
        "subtitle": data["subtitle"],
        "generated_at_utc": generated_at_utc,
        "default_path": data["default_path"],
        "blocks": [],
    }

    for block in data["blocks"]:
        ui_block = {
            "id": block["id"],
            "title": block["title"],
            "commentary": block.get("commentary", []),
            "references": block.get("references", []),
            "snippets": [],
        }
        for snippet in block.get("snippets", []):
            snippet_payload = read_snippet(snippet["path"], snippet["start"], snippet["end"])
            snippet_payload["label"] = snippet["label"]
            ui_block["snippets"].append(snippet_payload)
        ui_data["blocks"].append(ui_block)

    return ui_data


def main() -> None:
    data = json.loads(SOURCE_PATH.read_text(encoding="utf-8"))
    generated_at_utc = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")

    outputs = data["outputs"]
    md_out = ROOT / outputs["markdown"]
    ui_out = ROOT / outputs["ui_json"]

    markdown = generate_markdown(data, generated_at_utc)
    md_out.write_text(markdown, encoding="utf-8")

    ui_data = build_ui_data(data, generated_at_utc)
    ui_out.write_text(json.dumps(ui_data, indent=2) + "\n", encoding="utf-8")

    print(f"Wrote {md_out.relative_to(ROOT)}")
    print(f"Wrote {ui_out.relative_to(ROOT)}")


if __name__ == "__main__":
    main()
